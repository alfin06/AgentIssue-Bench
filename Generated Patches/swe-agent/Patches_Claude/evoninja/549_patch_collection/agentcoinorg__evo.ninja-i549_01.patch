diff --git a/packages/agents/src/agents/Developer/DeveloperAgent.spec.ts b/packages/agents/src/agents/Developer/DeveloperAgent.spec.ts
deleted file mode 100644
index 64be60e..0000000
--- a/packages/agents/src/agents/Developer/DeveloperAgent.spec.ts
+++ /dev/null
@@ -1,203 +0,0 @@
-import {
-  Chat,
-  LlmApi,
-  OpenAILlmApi,
-  OpenAIEmbeddingAPI,
-} from "@/agent-core";
-import * as rimraf from "rimraf";
-import dotenv from "dotenv";
-import path from "path";
-import cl100k_base from "gpt-tokenizer/cjs/encoding/cl100k_base";
-import fs from "fs";
-import { AgentContext } from "@/agent-core";
-import { LlmModel } from "@/agent-core";
-import { Agent } from "../utils";
-import { DeveloperAgent } from ".";
-import { Env, Logger, ConsoleLogger, Scripts, SubWorkspace } from "@evo-ninja/agent-utils";
-import { FileSystemWorkspace } from "@evo-ninja/agent-utils-fs";
-import { DebugLlmApi, DebugLog } from "@/agent-debug";
-
-const rootDir = path.join(__dirname, "../../../../../");
-
-dotenv.config({
-  path: path.join(rootDir, ".env")
-});
-
-jest.setTimeout(600000);
-
-describe('Dev Agent Test Suite', () => {
-
-  async function createDevAgent(
-    testName: string,
-    pathsForFilesToInclude: string[] = []
-  ): Promise<{
-    agent: Agent;
-    debugLog: DebugLog;
-  }> {
-    const testCaseDir = path.join(__dirname, ".tests", testName);
-
-    // reset the dir
-    rimraf.sync(testCaseDir);
-
-    const env = new Env(process.env as Record<string, string>);
-    const logger = new Logger([new ConsoleLogger()], {
-      promptUser: () => {
-        throw Error("promptUser not supported.");
-      },
-    });
-
-    const llm: LlmApi = new OpenAILlmApi(
-      env.OPENAI_API_KEY,
-      env.GPT_MODEL as LlmModel,
-      env.CONTEXT_WINDOW_TOKENS,
-      env.MAX_RESPONSE_TOKENS,
-      logger
-    );
-
-    const debugLog = new DebugLog(
-      new FileSystemWorkspace(path.join(testCaseDir, "./debug"))
-    );
-    const debugLlm = new DebugLlmApi(debugLog, llm);
-
-    const chat = new Chat(cl100k_base);
-
-    const scriptsDir = path.join(rootDir, "scripts");
-    const scriptsWorkspace = new FileSystemWorkspace(scriptsDir);
-    const scripts = new Scripts(scriptsWorkspace, "./");
-
-    const workspace = new FileSystemWorkspace(testCaseDir);
-    const internals = new SubWorkspace(".evo", workspace);
-    const embedding = new OpenAIEmbeddingAPI(env.OPENAI_API_KEY, logger, cl100k_base);
-
-    for (const filePath of pathsForFilesToInclude) {
-      if (!fs.existsSync(filePath)) {
-        throw Error(`Input file does not exist: ${filePath}`);
-      }
-      const fileName = path.basename(filePath);
-      const fileContents = fs.readFileSync(filePath, "utf-8");
-      await workspace.writeFile(fileName, fileContents);
-    }
-
-    return {
-      agent: new DeveloperAgent(
-        new AgentContext(
-          debugLlm,
-          embedding,
-          chat,
-          logger,
-          workspace,
-          internals,
-          env,
-          scripts
-        )
-      ),
-      debugLog,
-    };
-  }
-
-  async function runDevAgent(agent: Agent, goal: string, debugLog: DebugLog) {
-    await debugLog.goalStart(goal);
-    const iterator = agent.run({ goal });
-
-    while (true) {
-      await debugLog.stepStart();
-      const response = await iterator.next();
-      await debugLog.stepEnd();
-
-      if (response.done) {
-        if (!response.value.ok) {
-          await debugLog.stepError(response.value.error ?? "Unknown error");
-        } else {
-          await debugLog.stepLog(JSON.stringify(response.value.value));
-        }
-        return response;
-      }
-    }
-  }
-
-  test("tic-tac-toe", async () => {
-    const { agent, debugLog } = await createDevAgent("tic-tac-toe");
-    const response = await runDevAgent(
-      agent,
-      'Build a Tic-Tac-Toe game using a python CLI. Here are the specifications.\n\nThe Grid: The game board is a 3x3 grid, consisting of 3 rows and 3 columns, creating a total of 9 squares.\n\nPlayers: There are two players. One player uses the number "1", and the other player uses the number "2".\n\nTaking Turns: Players take turns to put their respective numbers ("1" or "2") in an empty square of the grid. Once a player has placed their number in a square, it cannot be changed or removed.\n\nObjective: The goal is to get three of your numbers in a row, either horizontally, vertically, or diagonally.\n\nEnd of the Game: The game concludes in one of two ways: One player gets three of their numbers in a row (horizontally, vertically, or diagonally) and is declared the winner.\nAll squares on the grid are filled, and no player has three in a row. This situation is a "draw" or a "tie".\n\nTechnical specifications:\nBuild a file called tic_tac_toe.py. This file will be called through command lines. You will have to prompt users for their move. Player 1 will always start.\nPlayers will input their move in the following format: "x,y" where x and y represent the location in the grid (0,0 is top left, 2,2 is bottom right).\n\nYour primary requirement is to halt the game when appropriate and to print only one of these three exact sentences:\n\n"Player 1 won!"\n"Player 2 won!"\n"Draw"\n\nEdge cases: A player can send an incorrect location. Either the location is incorrect or the square is already filled. In this case, this counts as doing nothing, and the player gets prompted for new locations again.\n\n\nYou will be expected to create a python file called tic_tac_toe.py that will run through command lines by using ```python tic_tac_toe.py```.\n\nHere is an example of how your tic_tac_toe.py game will be tested.\n```\nprocess = subprocess.Popen(\n    [\'python\', \'tic_tac_toe.py\'],\n    stdout=subprocess.PIPE,\n    text=True\n)\n\noutput, _ = process.communicate(\'\\n\'.join(["0,0", "1,0", "0,1", "1,1", "0,2"]))\n\nassert "Player 1 won!" in output\n```',
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("tic_tac_toe.py");
-    expect(sourceCode).toBeTruthy();
-  });
-
-  test("three-sum", async () => {
-    const { agent, debugLog } = await createDevAgent("three-sum");
-    const response = await runDevAgent(
-      agent,
-      "Create a three_sum function in a file called sample_code.py. Given an array of integers, return indices of the three numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 20, Because nums[0] + nums[1] + nums[2] = 2 + 7 + 11 = 20, return [0, 1, 2].",
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("sample_code.py");
-    expect(sourceCode).toBeTruthy();
-  });
-
-  test("FileOrganizer", async () => {
-    const { agent, debugLog } = await createDevAgent("FileOrganizer");
-    const response = await runDevAgent(
-      agent,
-      "Create a file organizer CLI tool in Python that sorts files in a directory based on their file types (e.g., images, documents, audio) and moves them into these corresponding folders: 'images', 'documents', 'audio'. The entry point will be a python file that can be run this way: python organize_files.py --directory_path=YOUR_DIRECTORY_PATH",
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("organize_files.py");
-    expect(sourceCode).toBeTruthy();
-  });
-
-  test("Battleship", async () => {
-    const { agent, debugLog } = await createDevAgent("Battleship", [
-      path.join(__dirname, "testInputs/Battleship/__init__.py"),
-      path.join(__dirname, "testInputs/Battleship/abstract_class.py"),
-      path.join(__dirname, "testInputs/Battleship/conftest.py"),
-      path.join(__dirname, "testInputs/Battleship/product_requirements.txt"),
-      path.join(__dirname, "testInputs/Battleship/test_negative.py"),
-      path.join(__dirname, "testInputs/Battleship/test_positive.py"),
-      path.join(__dirname, "testInputs/Battleship/user_stories.txt"),
-    ]);
-    const response = await runDevAgent(
-      agent,
-      'Build a battleship game\n\nSpecifications:\n\nOverview: Battleship is a two-player strategy game where each player places their fleet of ships on a grid and tries to sink the opponent\'s fleet by guessing their locations.\nPlayers take turns calling out a row and column, attempting to name a square containing one of the opponent\'s ships.\n\nThe Grid: Each player\'s grid is a 10x10 grid, identified by rows (using numbers 1-10) and columns (using letters A-J).\n\nShips:\n\nCarrier - 5 squares\nBattleship - 4 squares\nCruiser - 3 squares\nSubmarine - 3 squares\nDestroyer - 2 squares\nEach ship occupies contiguous squares on the grid, arranged either horizontally or vertically.\n\nSetup:\n\nAt the start of the game, each player places their fleet on their grid. This setup is hidden from the opponent.\nThe game begins with Player 1, followed by Player 2, and so on.\nTaking Turns:\n\nOn a player\'s turn, they announce a grid square (e.g., "D5").\nThe opponent announces whether that square is a "hit" (if there\'s a part of a ship on that square) or "miss" (if the square is empty).\nIf a player hits a square occupied by a ship, they get another turn to guess. This continues until they make a miss, at which point their turn ends.\nIf a player hits all the squares occupied by a ship, the opponent must announce the sinking of that specific ship, e.g., "You sank my Battleship!"\n\nObjective: The goal is to sink all of your opponent\'s ships before they sink yours.\n\nEnd of the Game: The game ends when one player has sunk all of the opponent\'s ships. The winner is the player who sinks all the opposing fleet first.\n\nTechnical details:\nIn your root folder you will find an abstract class that defines the public interface of the Battleship class you will have to build:\n```\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\n\nfrom pydantic import BaseModel, validator\n\n\n# Models for the request and response payloads\nclass ShipPlacement(BaseModel):\n    ship_type: str\n    start: dict  # {"row": int, "column": str}\n    direction: str\n\n    @validator("start")\n    def validate_start(cls, start):\n        row, column = start.get("row"), start.get("column")\n\n        if not (1 <= row <= 10):\n            raise ValueError("Row must be between 1 and 10 inclusive.")\n\n        if column not in list("ABCDEFGHIJ"):\n            raise ValueError("Column must be one of A, B, C, D, E, F, G, H, I, J.")\n\n        return start\n\n\nclass Turn(BaseModel):\n    target: dict  # {"row": int, "column": str}\n\n\nclass TurnResponse(BaseModel):\n    result: str\n    ship_type: Optional[str]  # This would be None if the result is a miss\n\n\nclass GameStatus(BaseModel):\n    is_game_over: bool\n    winner: Optional[str]\n\n\nfrom typing import List\n\n\nclass Game(BaseModel):\n    game_id: str\n    players: List[str]\n    board: dict  # This could represent the state of the game board, you might need to flesh this out further\n    ships: List[ShipPlacement]  # List of ship placements for this game\n    turns: List[Turn]  # List of turns that have been taken\n\n\nclass AbstractBattleship(ABC):\n    SHIP_LENGTHS = {\n        "carrier": 5,\n        "battleship": 4,\n        "cruiser": 3,\n        "submarine": 3,\n        "destroyer": 2,\n    }\n\n    @abstractmethod\n    def create_ship_placement(self, game_id: str, placement: ShipPlacement) -> None:\n        """\n        Place a ship on the grid.\n        """\n        pass\n\n    @abstractmethod\n    def create_turn(self, game_id: str, turn: Turn) -> TurnResponse:\n        """\n        Players take turns to target a grid cell.\n        """\n        pass\n\n    @abstractmethod\n    def get_game_status(self, game_id: str) -> GameStatus:\n        """\n        Check if the game is over and get the winner if there\'s one.\n        """\n        pass\n\n    @abstractmethod\n    def get_winner(self, game_id: str) -> str:\n        """\n        Get the winner of the game.\n        """\n        pass\n\n    @abstractmethod\n    def get_game(self) -> Game:\n        """\n        Retrieve the state of the game.\n        """\n        pass\n\n    @abstractmethod\n    def delete_game(self, game_id: str) -> None:\n        """\n        Delete a game given its ID.\n        """\n        pass\n\n    @abstractmethod\n    def create_game(self, game_id: str) -> None:\n        """\n        Create a new game.\n        """\n        pass\n\n```\nAt any moment you can run ```pytest``` to execute the tests.\nYou have two types of test: \n- positive tests => test the battleship game being used in ideal conditions\n- negative tests => tests the battleship game behaviour when used incorrectly\n\nSuccess criteria:\n- you will need to write a file called battleship.py that implements the abstract Battleship class.\n- this class will have to pass all the tests.\n- you\'re not allowed to modify any other file than the battleship.py. You can add other files as long as the main entrypoint is the battleship class.',
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("battleship.py");
-    expect(sourceCode).toBeTruthy();
-  });
-
-  test("PasswordGenerator", async () => {
-    const { agent, debugLog } = await createDevAgent("PasswordGenerator");
-    const response = await runDevAgent(
-      agent,
-      "Create a random password generator. The password should have between 8 and 16 characters and should contain letters, numbers and symbols. The password should be printed to the console. The entry point will be a python file that can be run this way: python password_generator.py [--len x] where x is the length of the password. If no length is specified, the password should be 8 characters long. The password_generator can also be imported as a module and called as password = password_generator.generate_password(len=x). Any invalid input should raise a ValueError.",
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("password_generator.py");
-    expect(sourceCode).toBeTruthy();
-  });
-
-  test("UrlShortener", async () => {
-    const { agent, debugLog } = await createDevAgent("UrlShortener");
-    const response = await runDevAgent(
-      agent,
-      "Build a basic URL shortener using a python CLI. Here are the specifications.\n\nFunctionality: The program should have two primary functionalities.\n\nShorten a given URL.\nRetrieve the original URL from a shortened URL.\n\nCLI: The command-line interface should accept a URL as its first input. It should be able to determine if the url is a shortened url or not. If the url is not shortened, it will display ONLY the shortened url, otherwise, it will display ONLY the original unshortened URL. Afterwards, it should prompt the user for another URL to process.\n\nTechnical specifications:\nBuild a file called url_shortener.py. This file will be called through command lines.\n\nEdge cases:\nFor the sake of simplicity, there will be no edge cases, you can assume the input is always correct and the user immediately passes the shortened version of the url he just shortened.\n\nYou will be expected to create a python file called url_shortener.py that will run through command lines by using python url_shortener.py.\n\nThe url_shortener.py will be tested this way:\n```\nimport unittest\nfrom url_shortener import shorten_url, retrieve_url\n\nclass TestURLShortener(unittest.TestCase):\n    def test_url_retrieval(self):\n        # Shorten the URL to get its shortened form\n        shortened_url = shorten_url('https://www.example.com')\n\n        # Retrieve the original URL using the shortened URL directly\n        retrieved_url = retrieve_url(shortened_url)\n\n        self.assertEqual(retrieved_url, 'https://www.example.com', \"Retrieved URL does not match the original!\")\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
-      debugLog
-    );
-
-    expect(response.value.ok).toBe(true);
-    const sourceCode = await agent.workspace.readFile("url_shortener.py");
-    expect(sourceCode).toBeTruthy();
-  });
-});
\ No newline at end of file
diff --git a/packages/agents/src/agents/Developer/index.ts b/packages/agents/src/agents/Developer/index.ts
deleted file mode 100644
index 267167a..0000000
--- a/packages/agents/src/agents/Developer/index.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { ReadFileFunction } from "../../functions/ReadFile";
-import { AgentContext } from "@/agent-core";
-import { InitPoetryFunction } from "../../functions/InitPoetry";
-import { RunPytest } from "../../functions/RunPytest";
-import { WriteFileFunction } from "../../functions/WriteFile";
-import { ReadDirectoryFunction } from "../../functions";
-import { prompts } from "./prompts";
-import { Agent, AgentConfig } from "../utils";
-
-export class DeveloperAgent extends Agent {
-  constructor(context: AgentContext) {
-    super(
-      new AgentConfig(
-        () => prompts(),
-        [
-          new WriteFileFunction(context.scripts),
-          new ReadFileFunction(context.scripts),
-          new ReadDirectoryFunction(context.scripts),
-          /*new RunPytest(),
-          new InitPoetryFunction(),*/
-        ],
-        context.scripts
-      ),
-      context
-    );
-  }
-}
diff --git a/packages/agents/src/agents/Developer/prompts.ts b/packages/agents/src/agents/Developer/prompts.ts
deleted file mode 100644
index b9d360e..0000000
--- a/packages/agents/src/agents/Developer/prompts.ts
+++ /dev/null
@@ -1,34 +0,0 @@
-import { ChatMessage } from "@/agent-core";
-import { AgentPrompts, GoalRunArgs } from "../utils";
-
-export const prompts = (): AgentPrompts<GoalRunArgs> => ({
-  name: "Developer",
-  expertise: `architect and build complex software. specialized in python`,
-  initialMessages: (): ChatMessage[] => [
-    {
-      role: "user",
-      content: `You are an expert developer assistant that excels at coding related tasks.
-Before writing any code you must initiate the workspace using the function initPoetry.
-You plan and write clean and effective code to files using the writeFile function.
-The goal might contain information about how your implementation must be tested, if that the case,
-you must develop unit tests using the writeFile function, they must have the following structure:
-\`\`\`python
-import pytest
-
-def test_function_name_to_be_tested():
-    # tests should be here
-\`\`\`
-Remember that you must do unit tests, if you are told that the implementation will be tested through a CLI process,
-you still make unit tests without adding complex logic
-You will always make sure that the implementation and tests are created before running tests with function runPytest
-You must not interact with the user or ask question for clarification. Solve the task to the best of your abilities.`,
-    },
-  ],
-  runMessages: ({ goal }: GoalRunArgs): ChatMessage[] => [
-    {
-      role: "user",
-      content: goal,
-    },
-  ],
-  loopPreventionPrompt: `Assistant, you appear to be in a loop, try executing a different function.`,
-});
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/__init__.py b/packages/agents/src/agents/Developer/testInputs/Battleship/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/abstract_class.py b/packages/agents/src/agents/Developer/testInputs/Battleship/abstract_class.py
deleted file mode 100644
index dec3bcb..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/abstract_class.py
+++ /dev/null
@@ -1,107 +0,0 @@
-from abc import ABC, abstractmethod
-from typing import Optional
-
-from pydantic import BaseModel, validator
-
-
-# Models for the request and response payloads
-class ShipPlacement(BaseModel):
-    ship_type: str
-    start: dict  # {"row": int, "column": str}
-    direction: str
-
-    @validator("start")
-    def validate_start(cls, start):
-        row, column = start.get("row"), start.get("column")
-
-        if not (1 <= row <= 10):
-            raise ValueError("Row must be between 1 and 10 inclusive.")
-
-        if column not in list("ABCDEFGHIJ"):
-            raise ValueError("Column must be one of A, B, C, D, E, F, G, H, I, J.")
-
-        return start
-
-
-class Turn(BaseModel):
-    target: dict  # {"row": int, "column": str}
-
-
-class TurnResponse(BaseModel):
-    result: str
-    ship_type: Optional[str]  # This would be None if the result is a miss
-
-
-class GameStatus(BaseModel):
-    is_game_over: bool
-    winner: Optional[str]
-
-
-from typing import List
-
-
-class Game(BaseModel):
-    game_id: str
-    players: List[str]
-    board: dict  # This could represent the state of the game board, you might need to flesh this out further
-    ships: List[ShipPlacement]  # List of ship placements for this game
-    turns: List[Turn]  # List of turns that have been taken
-
-
-class AbstractBattleship(ABC):
-    SHIP_LENGTHS = {
-        "carrier": 5,
-        "battleship": 4,
-        "cruiser": 3,
-        "submarine": 3,
-        "destroyer": 2,
-    }
-
-    @abstractmethod
-    def create_ship_placement(self, game_id: str, placement: ShipPlacement) -> None:
-        """
-        Place a ship on the grid.
-        """
-        pass
-
-    @abstractmethod
-    def create_turn(self, game_id: str, turn: Turn) -> TurnResponse:
-        """
-        Players take turns to target a grid cell.
-        """
-        pass
-
-    @abstractmethod
-    def get_game_status(self, game_id: str) -> GameStatus:
-        """
-        Check if the game is over and get the winner if there's one.
-        """
-        pass
-
-    @abstractmethod
-    def get_winner(self, game_id: str) -> str:
-        """
-        Get the winner of the game.
-        """
-        pass
-
-    @abstractmethod
-    def get_game(self) -> Game:
-        """
-        Retrieve the state of the game.
-        """
-        pass
-
-    @abstractmethod
-    def delete_game(self, game_id: str) -> None:
-        """
-        Delete a game given its ID.
-        """
-        pass
-
-    @abstractmethod
-    def create_game(self) -> None:
-        """
-        Create a new game.
-        """
-        pass
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/conftest.py b/packages/agents/src/agents/Developer/testInputs/Battleship/conftest.py
deleted file mode 100644
index a141296..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/conftest.py
+++ /dev/null
@@ -1,61 +0,0 @@
-import pytest
-from abstract_class import ShipPlacement, Turn
-from battleship import Battleship
-
-
-@pytest.fixture
-def battleship_game():
-    return Battleship()
-
-
-@pytest.fixture
-def initialized_game_id(battleship_game):
-    # Create a game instance
-    game_id = battleship_game.create_game()
-
-    # Place all the ships using battleship_game's methods
-    sample_ship_placements = [
-        ShipPlacement(
-            ship_type="carrier", start={"row": 1, "column": "A"}, direction="horizontal"
-        ),
-        ShipPlacement(
-            ship_type="battleship",
-            start={"row": 2, "column": "A"},
-            direction="horizontal",
-        ),
-        ShipPlacement(
-            ship_type="cruiser", start={"row": 3, "column": "A"}, direction="horizontal"
-        ),
-        ShipPlacement(
-            ship_type="submarine",
-            start={"row": 4, "column": "A"},
-            direction="horizontal",
-        ),
-        ShipPlacement(
-            ship_type="destroyer",
-            start={"row": 5, "column": "A"},
-            direction="horizontal",
-        ),
-    ]
-
-    for ship_placement in sample_ship_placements:
-        # Place ship using battleship_game's methods
-        battleship_game.create_ship_placement(game_id, ship_placement)
-
-    return game_id
-
-
-@pytest.fixture
-def game_over_fixture(battleship_game, initialized_game_id):
-    # Assuming 10x10 grid, target all possible positions
-    for row in range(1, 11):
-        for column in list("ABCDEFGHIJ"):
-            # Player 1 takes a turn
-            turn = Turn(target={"row": row, "column": column})
-            battleship_game.create_turn(initialized_game_id, turn)
-
-            # Player 2 takes a turn, targeting the same position as Player 1
-            battleship_game.create_turn(initialized_game_id, turn)
-
-    # At the end of this fixture, the game should be over
-    return initialized_game_id
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/product_requirements.txt b/packages/agents/src/agents/Developer/testInputs/Battleship/product_requirements.txt
deleted file mode 100644
index d29c177..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/product_requirements.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-Specifications for Battleship
-
-Overview: Battleship is a two-player strategy game where each player places their fleet of ships on a grid and tries to sink the opponent's fleet by guessing their locations.
-Players take turns calling out a row and column, attempting to name a square containing one of the opponent's ships.
-
-The Grid: Each player's grid is a 10x10 grid, identified by rows (using numbers 1-10) and columns (using letters A-J).
-
-Ships:
-
-Carrier - 5 squares
-Battleship - 4 squares
-Cruiser - 3 squares
-Submarine - 3 squares
-Destroyer - 2 squares
-Each ship occupies contiguous squares on the grid, arranged either horizontally or vertically.
-
-Setup:
-
-At the start of the game, each player places their fleet on their grid. This setup is hidden from the opponent.
-The game begins with Player 1, followed by Player 2, and so on.
-Taking Turns:
-
-On a player's turn, they announce a grid square (e.g., "D5").
-The opponent announces whether that square is a "hit" (if there's a part of a ship on that square) or "miss" (if the square is empty).
-If a player hits a square occupied by a ship, they get another turn to guess. This continues until they make a miss, at which point their turn ends.
-If a player hits all the squares occupied by a ship, the opponent must announce the sinking of that specific ship, e.g., "You sank my Battleship!"
-
-Objective: The goal is to sink all of your opponent's ships before they sink yours.
-
-End of the Game: The game ends when one player has sunk all of the opponent's ships. The winner is the player who sinks all the opposing fleet first.
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/test_negative.py b/packages/agents/src/agents/Developer/testInputs/Battleship/test_negative.py
deleted file mode 100644
index 34bed48..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/test_negative.py
+++ /dev/null
@@ -1,100 +0,0 @@
-import pytest
-from abstract_class import ShipPlacement, Turn
-from pydantic import ValidationError
-
-
-def test_ship_placement_out_of_bounds(battleship_game):
-    game_id = battleship_game.create_game()
-
-    try:
-        out_of_bounds_ship = ShipPlacement(
-            ship_type="battleship",
-            start={"row": 11, "column": "Z"},
-            direction="horizontal",
-        )
-    except ValidationError:  # Use the directly imported ValidationError class
-        pass
-    else:
-        with pytest.raises(ValueError, match="Placement out of bounds"):
-            battleship_game.create_ship_placement(game_id, out_of_bounds_ship)
-
-
-def test_no_ship_overlap(battleship_game):
-    game_id = battleship_game.create_game()
-    placement1 = ShipPlacement(
-        ship_type="battleship", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, placement1)
-    placement2 = ShipPlacement(
-        ship_type="cruiser", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    with pytest.raises(ValueError):
-        battleship_game.create_ship_placement(game_id, placement2)
-
-
-def test_cant_hit_before_ships_placed(battleship_game):
-    game_id = battleship_game.create_game()
-    placement1 = ShipPlacement(
-        ship_type="battleship", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, placement1)
-    placement2 = ShipPlacement(
-        ship_type="cruiser", start={"row": 4, "column": "D"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, placement2)
-    turn = Turn(target={"row": 1, "column": "A"})
-    with pytest.raises(
-        ValueError, match="All ships must be placed before starting turns"
-    ):
-        battleship_game.create_turn(game_id, turn)
-
-
-def test_cant_place_ship_after_all_ships_placed(battleship_game, initialized_game_id):
-    game = battleship_game.get_game(initialized_game_id)
-    additional_ship = ShipPlacement(
-        ship_type="carrier", start={"row": 2, "column": "E"}, direction="horizontal"
-    )
-
-    with pytest.raises(
-        ValueError, match="All ships are already placed. Cannot place more ships."
-    ):
-        battleship_game.create_ship_placement(initialized_game_id, additional_ship)
-
-
-def test_ship_placement_invalid_direction(battleship_game):
-    game_id = battleship_game.create_game()
-
-    with pytest.raises(ValueError, match="Invalid ship direction"):
-        invalid_direction_ship = ShipPlacement(
-            ship_type="battleship",
-            start={"row": 1, "column": "A"},
-            direction="diagonal",
-        )
-        battleship_game.create_ship_placement(game_id, invalid_direction_ship)
-
-
-def test_invalid_ship_type(battleship_game):
-    game_id = battleship_game.create_game()
-    invalid_ship = ShipPlacement(
-        ship_type="spacecraft", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    with pytest.raises(ValueError, match="Invalid ship type"):
-        battleship_game.create_ship_placement(game_id, invalid_ship)
-
-
-def test_ship_placement_extends_beyond_boundaries(battleship_game):
-    game_id = battleship_game.create_game()
-
-    with pytest.raises(ValueError, match="Ship extends beyond board boundaries"):
-        ship_extending_beyond = ShipPlacement(
-            ship_type="battleship",
-            start={"row": 1, "column": "H"},
-            direction="horizontal",
-        )
-        battleship_game.create_ship_placement(game_id, ship_extending_beyond)
-
-    with pytest.raises(ValueError, match="Ship extends beyond board boundaries"):
-        ship_extending_beyond = ShipPlacement(
-            ship_type="cruiser", start={"row": 9, "column": "A"}, direction="vertical"
-        )
-        battleship_game.create_ship_placement(game_id, ship_extending_beyond)
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/test_positive.py b/packages/agents/src/agents/Developer/testInputs/Battleship/test_positive.py
deleted file mode 100644
index 203b90c..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/test_positive.py
+++ /dev/null
@@ -1,149 +0,0 @@
-from abstract_class import ShipPlacement, Turn
-
-
-def test_turns_and_results(battleship_game, initialized_game_id):
-    turn = Turn(target={"row": 1, "column": "A"})
-    response = battleship_game.create_turn(initialized_game_id, turn)
-
-    assert response.result in ["hit", "miss"]
-    if response.result == "hit":
-        assert response.ship_type == "carrier"
-    game = battleship_game.get_game(initialized_game_id)
-    assert turn in game.turns
-
-
-def test_game_status_and_winner(battleship_game):
-    game_id = battleship_game.create_game()
-    status = battleship_game.get_game_status(game_id)
-    assert isinstance(status.is_game_over, bool)
-    if status.is_game_over:
-        winner = battleship_game.get_winner(game_id)
-        assert winner is not None
-
-
-def test_delete_game(battleship_game):
-    game_id = battleship_game.create_game()
-    battleship_game.delete_game(game_id)
-    assert battleship_game.get_game(game_id) is None
-
-
-def test_ship_rotation(battleship_game):
-    game_id = battleship_game.create_game()
-    placement_horizontal = ShipPlacement(
-        ship_type="battleship", start={"row": 1, "column": "B"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, placement_horizontal)
-    placement_vertical = ShipPlacement(
-        ship_type="cruiser", start={"row": 3, "column": "D"}, direction="vertical"
-    )
-    battleship_game.create_ship_placement(game_id, placement_vertical)
-    game = battleship_game.get_game(game_id)
-    assert placement_horizontal in game.ships
-    assert placement_vertical in game.ships
-
-
-def test_game_state_updates(battleship_game, initialized_game_id):
-    turn = Turn(target={"row": 3, "column": "A"})
-    battleship_game.create_turn(initialized_game_id, turn)
-
-    game = battleship_game.get_game(initialized_game_id)
-
-    target_key = (3, ord("A") - ord("A"))
-    assert target_key in game.board and game.board[target_key] == "hit"
-
-
-def test_ship_sinking_feedback(battleship_game, initialized_game_id):
-    hits = ["A", "B", "C", "D"]
-    static_moves = [
-        {"row": 1, "column": "E"},
-        {"row": 1, "column": "F"},
-        {"row": 1, "column": "G"},
-        {"row": 1, "column": "H"},
-    ]
-
-    for index, hit in enumerate(hits):
-        turn = Turn(target={"row": 2, "column": hit})
-        response = battleship_game.create_turn(initialized_game_id, turn)
-        assert response.ship_type == "battleship"
-
-        static_turn = Turn(target=static_moves[index])
-        battleship_game.create_turn(initialized_game_id, static_turn)
-
-    assert response.result == "sunk"
-
-
-def test_restart_game(battleship_game):
-    game_id = battleship_game.create_game()
-    battleship_game.delete_game(game_id)
-    game_id = (
-        battleship_game.create_game()
-    )  # Use the returned game_id after recreating the game
-    game = battleship_game.get_game(game_id)
-    assert game is not None
-
-
-def test_ship_edge_overlapping(battleship_game):
-    game_id = battleship_game.create_game()
-
-    first_ship = ShipPlacement(
-        ship_type="battleship", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, first_ship)
-
-    next_ship = ShipPlacement(
-        ship_type="cruiser", start={"row": 1, "column": "E"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, next_ship)
-
-    game = battleship_game.get_game(game_id)
-    assert first_ship in game.ships
-    assert next_ship in game.ships
-
-
-def test_game_state_after_ship_placement(battleship_game):
-    game_id = battleship_game.create_game()
-
-    ship_placement = ShipPlacement(
-        ship_type="battleship", start={"row": 1, "column": "A"}, direction="horizontal"
-    )
-    battleship_game.create_ship_placement(game_id, ship_placement)
-
-    game = battleship_game.get_game(game_id)
-    assert ship_placement in game.ships
-
-
-def test_game_state_after_turn(initialized_game_id, battleship_game):
-    turn = Turn(target={"row": 1, "column": "A"})
-    response = battleship_game.create_turn(initialized_game_id, turn)
-
-    game = battleship_game.get_game(initialized_game_id)
-
-    if response.result == "hit":
-        assert game.board[(1, 0)] == "hit"
-    else:
-        assert game.board[1][0] == "miss"
-
-
-def test_multiple_hits_on_ship(battleship_game, initialized_game_id):
-    hit_positions = ["A", "B", "C", "D", "E"]
-
-    for index, pos in enumerate(hit_positions):
-        turn = Turn(target={"row": 1, "column": pos})
-        response = battleship_game.create_turn(initialized_game_id, turn)
-
-        if index == len(hit_positions) - 1:
-            assert response.result == "sunk"
-        else:
-            assert response.result == "hit"
-
-
-def test_game_over_condition(battleship_game, initialized_game_id):
-    for row in range(1, 11):
-        for column in list("ABCDEFGHIJ"):
-            turn = Turn(target={"row": row, "column": column})
-            battleship_game.create_turn(initialized_game_id, turn)
-
-            battleship_game.create_turn(initialized_game_id, turn)
-
-    status = battleship_game.get_game_status(initialized_game_id)
-    assert status.is_game_over
diff --git a/packages/agents/src/agents/Developer/testInputs/Battleship/user_stories.txt b/packages/agents/src/agents/Developer/testInputs/Battleship/user_stories.txt
deleted file mode 100644
index 95d1754..0000000
--- a/packages/agents/src/agents/Developer/testInputs/Battleship/user_stories.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-Setup and Start
-
-As a player, I want to start a new game so I can compete against my opponent.
-As a player, I want to position my ships on a 10x10 grid so that I can set up my strategy.
-As a player, I want to rotate my ships horizontally or vertically so I can choose their orientation.
-As a player, I want to be ensured that ships do not overlap when placing them so that the game rules are maintained.
-As a player, I want to hide my ship placements from my opponent so that my strategy remains a secret.
-
-Gameplay
-
-As a player, I want to call out a grid square during my turn so I can try to hit my opponent's ships.
-As a player, when I successfully hit a ship, I want to take another turn immediately so I can capitalize on my successful guess.
-As a player, when it's not my turn, I want to respond if the grid square called by my opponent is a "hit" or "miss" so that the game progresses.
-As a player, I want feedback on whether my guess was a "hit" or "miss" so that I can adjust my strategy.
-As a player, when my ship is completely hit, I want to inform my opponent which of my ships they have sunk, so they know their progress.
-As a player, I want to keep track of my hits and misses so I can strategize my future moves.
-
-Endgame
-
-As a player, I want to be notified when all my ships have been sunk so I know I've lost.
-As a player, I want to be notified when I have sunk all my opponent's ships so I know I've won.
-As a player, I want to have the option to start a new game after one ends so I can play again.
-
-User Experience
-
-As a player, I want clear visuals of my grid and my opponent's grid (with hits and misses) so I can easily understand the game state.
-As a player, I want audible feedback (like a splash or explosion) so that hits and misses are more engaging.
-As a player, I want to be able to pause or exit the game if needed so that I can resume or quit as per my convenience.
-
-Not Allowed
-As a player, I shouldn't be able to start hitting ships until all the ships are placed
diff --git a/packages/agents/src/agents/Evo/findBestAgent.ts b/packages/agents/src/agents/Evo/findBestAgent.ts
index 62f5724..1483fb0 100644
--- a/packages/agents/src/agents/Evo/findBestAgent.ts
+++ b/packages/agents/src/agents/Evo/findBestAgent.ts
@@ -2,7 +2,6 @@ import { FunctionDefinition, Rag, ArrayRecombiner } from "@/agent-core";
 import { AgentContext } from "@/agent-core";
 import { AgentFunctionBase } from "../../functions/utils";
 import { Agent, GoalRunArgs } from "../utils/Agent";
-import { DeveloperAgent } from "../Developer";
 import { CsvAnalystAgent } from "../CsvAnalyst";
 import { ResearcherAgent } from "../Researcher";
 import { SynthesizerAgent } from "../Synthesizer";
@@ -28,7 +27,6 @@ export const findBestAgent = async (
   AgentFunctionBase<unknown>[]
 ]> => {
   const allAgents: Agent[] = [
-    DeveloperAgent,
     CsvAnalystAgent,
     ResearcherAgent,
     SynthesizerAgent,
diff --git a/test_evo_personas.ts b/test_evo_personas.ts
new file mode 100644
index 0000000..250ad4d
--- /dev/null
+++ b/test_evo_personas.ts
@@ -0,0 +1,56 @@
+import { AgentContext } from "@/agent-core";
+import { Evo } from "./packages/agents/src/agents/Evo";
+import { findBestAgent } from "./packages/agents/src/agents/Evo/findBestAgent";
+
+// Mock context
+const mockContext = {
+  cloneEmpty: () => mockContext,
+  logger: {
+    info: async (msg: string) => console.log(msg),
+    notice: async (msg: string) => console.log(msg)
+  },
+  scripts: {},
+  llm: {
+    getMaxContextTokens: () => 8000,
+    getMaxResponseTokens: () => 1000,
+    getModel: () => "gpt-4"
+  },
+  chat: {
+    chatLogs: {
+      messages: []
+    },
+    tokenizer: {
+      encode: (text: string) => Array(text.length).fill(0)
+    },
+    persistent: async (msgs: any[]) => {}
+  },
+  variables: {
+    saveThreshold: 1000
+  },
+  workspace: {
+    readdir: async () => []
+  }
+} as unknown as AgentContext;
+
+// Create Evo instance
+const evo = new Evo(mockContext);
+
+// Test that Evo knows about its personas
+console.log("Testing Evo's knowledge of personas...");
+const prompts = evo["config"].prompts;
+console.log("Evo's expertise:", prompts.expertise);
+console.log("Evo's personas:", prompts.initialMessages());
+
+// Test that Developer agent is not available
+console.log("\nTesting that Developer agent is not available...");
+findBestAgent([0.1, 0.2, 0.3], mockContext)
+  .then(([agent]) => {
+    console.log("Selected agent:", agent.config.prompts.name);
+    if (agent.config.prompts.name === "Developer") {
+      throw new Error("Developer agent should not be available!");
+    }
+  })
+  .catch(err => {
+    console.error("Error:", err);
+    process.exit(1);
+  });
\ No newline at end of file
